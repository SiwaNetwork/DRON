<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>PNTP Swarm Simulator</title>
	<style>
		body { font-family: system-ui, sans-serif; margin: 20px; }
		.container { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
		.card { border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
		input, select, button { padding: 6px 8px; margin: 4px 0; width: 100%; }
		.metrics { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
		.metric { background: #f7f7f7; padding: 8px; border-radius: 6px; }
		canvas { width: 100%; height: 280px; background: #fff; border: 1px solid #eee; }
		.small { font-size: 12px; color: #666; }
	</style>
</head>
<body>
	<h1>PNTP Swarm Simulator</h1>
	<div class="container">
		<div class="card">
			<h3>Конфигурация</h3>
			<label>Число узлов</label>
			<input id="num_nodes" type="number" min="2" max="200" value="30" />
			<label>Тип часов мастера</label>
			<select id="master_clock_type">
				<option>RB</option>
				<option>OCXO</option>
				<option>TCXO</option>
				<option>QUARTZ</option>
			</select>
			<label>dt (сек)</label>
			<input id="dt" type="number" min="0.01" step="0.01" value="0.1" />
			<label>Интервал телеметрии (сек)</label>
			<input id="tel_interval" type="number" min="0.1" step="0.1" value="0.5" />
			<button id="start_btn">Старт</button>
			<button id="stop_btn">Стоп</button>
			<div class="small" id="status"></div>
		</div>
		<div class="card">
			<h3>Телеметрия</h3>
			<div class="metrics">
				<div class="metric"><div>Покрытие</div><div id="m_cov">-</div></div>
				<div class="metric"><div>Средн. смещение (мкс)</div><div id="m_avg_off">-</div></div>
				<div class="metric"><div>Живучесть</div><div id="m_res">-</div></div>
			</div>
			<canvas id="chart" width="800" height="280"></canvas>
		</div>
	</div>

	<script>
	const statusEl = document.getElementById('status');
	const mCov = document.getElementById('m_cov');
	const mAvg = document.getElementById('m_avg_off');
	const mRes = document.getElementById('m_res');
	const canvas = document.getElementById('chart');
	const ctx = canvas.getContext('2d');
	const history = { t: [], cov: [], avgOff: [], res: [] };

	function drawChart() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.fillStyle = '#333';
		ctx.font = '12px sans-serif';
		ctx.fillText('Покрытие (синяя), Смещение мкс (зелёная), Живучесть (пурпурная)', 10, 14);
		const maxPoints = 200;
		['t','cov','avgOff','res'].forEach(k => { if (history[k].length > maxPoints) { history[k].shift(); } });
		const pad = 30, W = canvas.width - pad*2, H = canvas.height - pad*2;
		ctx.strokeStyle = '#ccc';
		ctx.strokeRect(pad, pad, W, H);
		if (history.t.length < 2) return;
		const n = history.t.length;
		const x = i => pad + W * (i / (n-1));
		const y1 = v => pad + (1 - Math.max(0, Math.min(1, v))) * H; // 0..1
		const maxAbs = Math.max(1, ...history.avgOff.map(v => Math.abs(v)));
		const y2 = v => pad + (1 - (0.5 + 0.5 * (v / maxAbs))) * H; // avgOff centered
		// cov
		ctx.strokeStyle = '#1e88e5'; ctx.beginPath(); ctx.moveTo(x(0), y1(history.cov[0]||0));
		for (let i=1;i<n;i++) ctx.lineTo(x(i), y1(history.cov[i]||0)); ctx.stroke();
		// avgOff
		ctx.strokeStyle = '#43a047'; ctx.beginPath(); ctx.moveTo(x(0), y2(history.avgOff[0]||0));
		for (let i=1;i<n;i++) ctx.lineTo(x(i), y2(history.avgOff[i]||0)); ctx.stroke();
		// res
		ctx.strokeStyle = '#8e24aa'; ctx.beginPath(); ctx.moveTo(x(0), y1(history.res[0]||0));
		for (let i=1;i<n;i++) ctx.lineTo(x(i), y1(history.res[i]||0)); ctx.stroke();
	}

	let ws;
	function connectWS() {
		const proto = location.protocol === 'https:' ? 'wss' : 'ws';
		ws = new WebSocket(`${proto}://${location.host}/ws`);
		ws.onopen = () => { statusEl.textContent = 'WebSocket подключен'; };
		ws.onmessage = (ev) => {
			try {
				const msg = JSON.parse(ev.data);
				if (msg.type === 'telemetry') {
					const m = msg.ensemble;
					mCov.textContent = (m.sync_coverage || 0).toFixed(3);
					mAvg.textContent = (m.average_offset || 0).toFixed(2);
					mRes.textContent = (m.failure_resilience || 0).toFixed(3);
					history.t.push(Date.now()/1000);
					history.cov.push(m.sync_coverage || 0);
					history.avgOff.push(m.average_offset || 0);
					history.res.push(m.failure_resilience || 0);
					drawChart();
				}
			} catch(e) {}
		};
		ws.onclose = () => { statusEl.textContent = 'WebSocket отключен'; setTimeout(connectWS, 1500); };
	}

	document.getElementById('start_btn').onclick = async () => {
		const body = {
			num_nodes: Number(document.getElementById('num_nodes').value),
			master_clock_type: document.getElementById('master_clock_type').value,
			dt_seconds: Number(document.getElementById('dt').value),
			telemetry_interval_seconds: Number(document.getElementById('tel_interval').value),
		};
		await fetch('/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
		statusEl.textContent = 'Симуляция запущена';
		history.t.length = history.cov.length = history.avgOff.length = history.res.length = 0;
		drawChart();
		if (!ws || ws.readyState !== WebSocket.OPEN) connectWS();
	};
	
document.getElementById('stop_btn').onclick = async () => {
		await fetch('/stop', { method: 'POST' });
		statusEl.textContent = 'Симуляция остановлена';
	};
	</script>
</body>
</html>